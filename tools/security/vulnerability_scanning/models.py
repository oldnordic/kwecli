"""
Data models for vulnerability scanning system.

Defines the core data structures for vulnerability scanning,
results, and package information following OSV and CVSS standards.
"""

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Dict, Any, List, Optional, Set
from decimal import Decimal


class ScanStatus(Enum):
    """Vulnerability scan status enumeration."""
    QUEUED = "queued"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"


class VulnerabilitySeverity(Enum):
    """Vulnerability severity levels following CVSS standards."""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"
    UNKNOWN = "unknown"


class PackageEcosystem(Enum):
    """Supported package ecosystems."""
    NPM = "npm"
    PYPI = "pypi" 
    CARGO = "cargo"
    MAVEN = "maven"
    NUGET = "nuget"
    GO = "go"
    RUBYGEMS = "rubygems"
    COMPOSER = "composer"


class VulnerabilitySource(Enum):
    """Vulnerability data sources."""
    OSV = "osv"
    NVD = "nvd"
    GITHUB_ADVISORY = "github_advisory"
    SNYK = "snyk"
    INTERNAL = "internal"


@dataclass
class PackageInfo:
    """Package information for vulnerability scanning."""
    name: str
    version: str
    ecosystem: PackageEcosystem
    purl: Optional[str] = None  # Package URL
    file_path: Optional[str] = None
    lock_file_path: Optional[str] = None
    dependencies: List['PackageInfo'] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        """Validate package information."""
        if not self.name or not self.version:
            raise ValueError("Package name and version are required")
        
        # Generate PURL if not provided
        if not self.purl:
            self.purl = self._generate_purl()
    
    def _generate_purl(self) -> str:
        """Generate Package URL following spec."""
        ecosystem_mapping = {
            PackageEcosystem.NPM: "npm",
            PackageEcosystem.PYPI: "pypi",
            PackageEcosystem.CARGO: "cargo",
            PackageEcosystem.MAVEN: "maven",
            PackageEcosystem.NUGET: "nuget",
            PackageEcosystem.GO: "golang",
            PackageEcosystem.RUBYGEMS: "gem",
            PackageEcosystem.COMPOSER: "composer"
        }
        
        ecosystem = ecosystem_mapping.get(self.ecosystem, self.ecosystem.value)
        return f"pkg:{ecosystem}/{self.name}@{self.version}"
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary format."""
        return {
            "name": self.name,
            "version": self.version,
            "ecosystem": self.ecosystem.value,
            "purl": self.purl,
            "file_path": self.file_path,
            "lock_file_path": self.lock_file_path,
            "dependencies": [dep.to_dict() for dep in self.dependencies],
            "metadata": self.metadata
        }


@dataclass
class CVSSScore:
    """CVSS scoring information."""
    version: str  # "3.1" or "4.0"
    vector_string: str
    base_score: Decimal
    temporal_score: Optional[Decimal] = None
    environmental_score: Optional[Decimal] = None
    
    def __post_init__(self):
        """Validate CVSS score."""
        if not (0 <= self.base_score <= 10):
            raise ValueError(f"Invalid CVSS base score: {self.base_score}")


@dataclass
class VulnerabilityReference:
    """Vulnerability reference information."""
    url: str
    type: str  # "ADVISORY", "ARTICLE", "REPORT", "FIX", "PACKAGE", "EVIDENCE", "WEB"
    description: Optional[str] = None


@dataclass
class VulnerabilityAffected:
    """Information about affected package versions."""
    package: PackageInfo
    ranges: List[Dict[str, Any]] = field(default_factory=list)  # Version ranges
    versions: List[str] = field(default_factory=list)  # Specific versions
    ecosystem_specific: Dict[str, Any] = field(default_factory=dict)


@dataclass
class VulnerabilityDetails:
    """Detailed vulnerability information following OSV schema."""
    id: str  # CVE-ID or other vulnerability identifier
    summary: str
    details: str
    severity: VulnerabilitySeverity
    source: VulnerabilitySource
    
    # CVSS scoring
    cvss_scores: List[CVSSScore] = field(default_factory=list)
    
    # Affected packages
    affected: List[VulnerabilityAffected] = field(default_factory=list)
    
    # References and metadata
    references: List[VulnerabilityReference] = field(default_factory=list)
    aliases: List[str] = field(default_factory=list)  # Other IDs for same vuln
    
    # Timing information
    published: Optional[datetime] = None
    modified: Optional[datetime] = None
    withdrawn: Optional[datetime] = None
    
    # Additional context
    database_specific: Dict[str, Any] = field(default_factory=dict)
    ecosystem_specific: Dict[str, Any] = field(default_factory=dict)
    
    def get_primary_cvss_score(self) -> Optional[Decimal]:
        """Get the primary CVSS base score."""
        if not self.cvss_scores:
            return None
        
        # Prefer CVSS 4.0, then 3.1, then others
        for score in sorted(self.cvss_scores, key=lambda s: s.version, reverse=True):
            return score.base_score
        
        return self.cvss_scores[0].base_score if self.cvss_scores else None
    
    def is_high_severity(self) -> bool:
        """Check if vulnerability is high or critical severity."""
        return self.severity in [VulnerabilitySeverity.HIGH, VulnerabilitySeverity.CRITICAL]
    
    def has_known_exploits(self) -> bool:
        """Check if vulnerability has known exploits."""
        # Check references for exploit indicators
        exploit_indicators = ["exploit", "poc", "proof-of-concept", "exploit-db"]
        return any(
            any(indicator in ref.url.lower() or 
                (ref.description and indicator in ref.description.lower())
                for indicator in exploit_indicators)
            for ref in self.references
        )
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary format."""
        return {
            "id": self.id,
            "summary": self.summary,
            "details": self.details,
            "severity": self.severity.value,
            "source": self.source.value,
            "cvss_scores": [
                {
                    "version": score.version,
                    "vector_string": score.vector_string,
                    "base_score": float(score.base_score),
                    "temporal_score": float(score.temporal_score) if score.temporal_score else None,
                    "environmental_score": float(score.environmental_score) if score.environmental_score else None
                }
                for score in self.cvss_scores
            ],
            "affected": [affected.package.to_dict() for affected in self.affected],
            "references": [
                {
                    "url": ref.url,
                    "type": ref.type,
                    "description": ref.description
                }
                for ref in self.references
            ],
            "aliases": self.aliases,
            "published": self.published.isoformat() if self.published else None,
            "modified": self.modified.isoformat() if self.modified else None,
            "withdrawn": self.withdrawn.isoformat() if self.withdrawn else None,
            "database_specific": self.database_specific,
            "ecosystem_specific": self.ecosystem_specific
        }


@dataclass
class ScanResult:
    """Results from a vulnerability scan."""
    scan_id: str
    package: PackageInfo
    status: ScanStatus
    vulnerabilities: List[VulnerabilityDetails] = field(default_factory=list)
    scan_timestamp: datetime = field(default_factory=datetime.now)
    scan_duration_seconds: Optional[float] = None
    sources_queried: List[VulnerabilitySource] = field(default_factory=list)
    errors: List[str] = field(default_factory=list)
    warnings: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    @property
    def vulnerability_count(self) -> int:
        """Get total number of vulnerabilities found."""
        return len(self.vulnerabilities)
    
    @property 
    def critical_count(self) -> int:
        """Get count of critical vulnerabilities."""
        return sum(1 for v in self.vulnerabilities 
                  if v.severity == VulnerabilitySeverity.CRITICAL)
    
    @property
    def high_count(self) -> int:
        """Get count of high severity vulnerabilities."""
        return sum(1 for v in self.vulnerabilities 
                  if v.severity == VulnerabilitySeverity.HIGH)
    
    @property
    def severity_counts(self) -> Dict[str, int]:
        """Get counts by severity level."""
        counts = {severity.value: 0 for severity in VulnerabilitySeverity}
        for vuln in self.vulnerabilities:
            counts[vuln.severity.value] += 1
        return counts
    
    def get_vulnerabilities_by_severity(self, severity: VulnerabilitySeverity) -> List[VulnerabilityDetails]:
        """Get vulnerabilities filtered by severity."""
        return [v for v in self.vulnerabilities if v.severity == severity]
    
    def has_blocking_vulnerabilities(self, policy_thresholds: Optional[Dict[str, Decimal]] = None) -> bool:
        """Check if scan has vulnerabilities that should block deployment."""
        if policy_thresholds is None:
            # Default thresholds
            policy_thresholds = {
                "critical": Decimal("9.0"),
                "high": Decimal("7.0")
            }
        
        for vuln in self.vulnerabilities:
            cvss_score = vuln.get_primary_cvss_score()
            if not cvss_score:
                continue
                
            if (vuln.severity == VulnerabilitySeverity.CRITICAL and 
                cvss_score >= policy_thresholds.get("critical", Decimal("9.0"))):
                return True
                
            if (vuln.severity == VulnerabilitySeverity.HIGH and 
                cvss_score >= policy_thresholds.get("high", Decimal("7.0"))):
                return True
        
        return False
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary format."""
        return {
            "scan_id": self.scan_id,
            "package": self.package.to_dict(),
            "status": self.status.value,
            "vulnerabilities": [v.to_dict() for v in self.vulnerabilities],
            "scan_timestamp": self.scan_timestamp.isoformat(),
            "scan_duration_seconds": self.scan_duration_seconds,
            "sources_queried": [s.value for s in self.sources_queried],
            "errors": self.errors,
            "warnings": self.warnings,
            "metadata": self.metadata,
            "summary": {
                "total_vulnerabilities": self.vulnerability_count,
                "severity_counts": self.severity_counts,
                "has_critical": self.critical_count > 0,
                "has_high": self.high_count > 0
            }
        }


@dataclass
class ScanRequest:
    """Request for vulnerability scanning."""
    packages: List[PackageInfo]
    scan_id: Optional[str] = None
    priority: int = 5  # 1-10, lower is higher priority
    
    # Scanning options
    include_transitive: bool = True
    sources_to_query: List[VulnerabilitySource] = field(default_factory=lambda: [
        VulnerabilitySource.OSV,
        VulnerabilitySource.NVD,
        VulnerabilitySource.GITHUB_ADVISORY
    ])
    
    # Timeout and performance settings
    timeout_seconds: int = 300  # 5 minutes default
    max_concurrent_requests: int = 10
    use_cache: bool = True
    cache_ttl_seconds: int = 3600  # 1 hour
    
    # Policy integration
    apply_policy_filtering: bool = True
    minimum_severity: VulnerabilitySeverity = VulnerabilitySeverity.LOW
    
    # Metadata
    requested_by: Optional[str] = None
    request_timestamp: datetime = field(default_factory=datetime.now)
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        """Generate scan ID if not provided."""
        if not self.scan_id:
            import uuid
            self.scan_id = f"scan_{uuid.uuid4().hex[:8]}"
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary format."""
        return {
            "scan_id": self.scan_id,
            "packages": [p.to_dict() for p in self.packages],
            "priority": self.priority,
            "include_transitive": self.include_transitive,
            "sources_to_query": [s.value for s in self.sources_to_query],
            "timeout_seconds": self.timeout_seconds,
            "max_concurrent_requests": self.max_concurrent_requests,
            "use_cache": self.use_cache,
            "cache_ttl_seconds": self.cache_ttl_seconds,
            "apply_policy_filtering": self.apply_policy_filtering,
            "minimum_severity": self.minimum_severity.value,
            "requested_by": self.requested_by,
            "request_timestamp": self.request_timestamp.isoformat(),
            "metadata": self.metadata
        }


@dataclass
class BatchScanResult:
    """Results from scanning multiple packages."""
    batch_id: str
    request: ScanRequest
    results: List[ScanResult] = field(default_factory=list)
    status: ScanStatus = ScanStatus.QUEUED
    start_time: Optional[datetime] = None
    end_time: Optional[datetime] = None
    
    @property
    def total_vulnerabilities(self) -> int:
        """Get total vulnerabilities across all packages."""
        return sum(result.vulnerability_count for result in self.results)
    
    @property
    def total_critical(self) -> int:
        """Get total critical vulnerabilities."""
        return sum(result.critical_count for result in self.results)
    
    @property
    def total_high(self) -> int:
        """Get total high severity vulnerabilities."""
        return sum(result.high_count for result in self.results)
    
    @property
    def has_failures(self) -> bool:
        """Check if any scans failed."""
        return any(result.status == ScanStatus.FAILED for result in self.results)
    
    def get_summary(self) -> Dict[str, Any]:
        """Get summary statistics."""
        all_severities = {}
        for result in self.results:
            for severity, count in result.severity_counts.items():
                all_severities[severity] = all_severities.get(severity, 0) + count
        
        return {
            "batch_id": self.batch_id,
            "total_packages": len(self.request.packages),
            "completed_scans": len([r for r in self.results if r.status == ScanStatus.COMPLETED]),
            "failed_scans": len([r for r in self.results if r.status == ScanStatus.FAILED]),
            "total_vulnerabilities": self.total_vulnerabilities,
            "severity_breakdown": all_severities,
            "scan_duration": (
                (self.end_time - self.start_time).total_seconds() 
                if self.start_time and self.end_time else None
            ),
            "status": self.status.value
        }